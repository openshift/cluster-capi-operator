# apiVersion: v1
# kind: ConfigMap
# metadata:
#   annotations:
#     exclude.release.openshift.io/internal-openshift-hosted: "true"
#     include.release.openshift.io/self-managed-high-availability: "true"
#     include.release.openshift.io/single-node-developer: "true"
#     release.openshift.io/feature-set: CustomNoUpgrade,TechPreviewNoUpgrade
#   name: cluster-api-admission-policies
#   namespace: openshift-cluster-api
#   labels:
#     provider.cluster.x-k8s.io/name: "openshift-cluster-api"
#     provider.cluster.x-k8s.io/type: "core"
#     provider.cluster.x-k8s.io/version: "v0.0.0"
---
apiVersion: v1
kind: ConfigMap
metadata:
  annotations:
    exclude.release.openshift.io/internal-openshift-hosted: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/feature-set: CustomNoUpgrade,TechPreviewNoUpgrade
  name: cluster-api-custom-admission-policies
  namespace: openshift-cluster-api
  labels:
    provider.cluster.x-k8s.io/name: "openshift-cluster-api"
    provider.cluster.x-k8s.io/type: "core"
    provider.cluster.x-k8s.io/version: "v0.0.0"
data:
  components: |-
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: machine-api-machine-vap
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      paramRef:
        namespace: openshift-cluster-api
        # We 'Allow' here as we don't want to block MAPI Machine 
        # functionality when no CAPI machine (param) exists. 
        # This might happen when the synchronisation controller first
        # is installed or when an unmigrateable machine is encountered.
        parameterNotFoundAction: Allow
        selector: {}
      policyName: machine-api-machine-vap
      validationActions: [Deny]
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: machine-api-machine-vap
    spec:
      failurePolicy: Fail
    
      paramKind:
        apiVersion: cluster.x-k8s.io/v1beta2
        kind: Machine
    
      matchConstraints:
        resourceRules:
        - apiGroups:   ["machine.openshift.io"]
          apiVersions: ["v1beta1"]
          operations:  ["UPDATE"]
          resources:   ["machines"]
    
      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-only-non-service-account-requests
          expression: >-
            !(request.userInfo.username in [
                "system:serviceaccount:openshift-machine-api:machine-api-controllers",
                "system:serviceaccount:openshift-cluster-api:cluster-capi-operator"
            ])
        - name: check-authoritativeAPI-clusterapi
          expression: 'object.status.authoritativeAPI == "ClusterAPI"'
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'
    
      variables:
        # label maps
        - name: newLabels
          expression: "object.metadata.?labels.orValue({})"
        - name: oldLabels
          expression: "oldObject.metadata.?labels.orValue({})"
        - name: paramLabels
          expression: "params.metadata.?labels.orValue({})"
    
        # annotation maps
        - name: newAnn
          expression: "object.metadata.?annotations.orValue({})"
        - name: oldAnn
          expression: "oldObject.metadata.?annotations.orValue({})"
    
        - name: specLockedExceptAuthoritativeAPI
          expression: >
            [
              [object.spec.?lifecycleHooks,   oldObject.spec.?lifecycleHooks],
              [object.spec.?metadata,         oldObject.spec.?metadata],
              [object.spec.?providerID,       oldObject.spec.?providerID],
              [object.spec.?providerSpec,     oldObject.spec.?providerSpec],
              [object.spec.?taints,           oldObject.spec.?taints]
            ].all(p,
              p[0].hasValue()
                ? p[1].hasValue() && p[0].value() == p[1].value()
                : !p[1].hasValue()
            )

      # All validations must evaluate to TRUE
      validations:
        # Only spec.authoritativeAPI may change
        - expression: "variables.specLockedExceptAuthoritativeAPI"
          message:  "You may only modify spec.authoritativeAPI. Any other change inside .spec is not allowed. This is because status.authoritativeAPI is set to Cluster API."
    
        # Guard machine.openshift.io/*, kubernetes.io/* and cluster.x-k8s.io labels
        - expression: >
            !(
              variables.newLabels.exists(k,
                  (k.startsWith('machine.openshift.io') || k.startsWith('kubernetes.io') || k.contains('cluster.x-k8s.io/')) &&
                  (variables.oldLabels[?k].orValue(null) != variables.newLabels[k])
              ) ||
              variables.oldLabels.exists(k,
                  (k.startsWith('machine.openshift.io') || k.startsWith('kubernetes.io') || k.contains('cluster.x-k8s.io/')) &&
                  !(k in variables.newLabels)
              )
            )
          message: "Cannot add, modify or delete any machine.openshift.io/* or kubernetes.io/* label. This is because status.authoritativeAPI is set to Cluster API."
    
        # Guard machine.openshift.io/* and cluster(s).x-k8s.io annotations
        - expression: >
            !(
              variables.newAnn.exists(k,
                  (k.startsWith('machine.openshift.io') || k.contains('cluster.x-k8s.io') || k.contains('clusters.x-k8s.io')) &&
                  (variables.oldAnn[?k].orValue(null) != variables.newAnn[k])
              ) ||
              variables.oldAnn.exists(k,
                  (k.startsWith('machine.openshift.io') || k.contains('cluster.x-k8s.io') || k.contains('clusters.x-k8s.io')) &&
                  !(k in variables.newAnn)
              )
            )
          message: "Cannot add, modify or delete any machine.openshift.io/* annotation. This is because status.authoritativeAPI is set to Cluster API."
    
        # Param-controlled labels (labels on the CAPI machine) may change only to match the value on the CAPI Machine
        - expression: >
            variables.paramLabels.all(
              k,
              variables.newLabels[?k].orValue(null) == variables.oldLabels[?k].orValue(null) ||
              variables.newLabels[?k].orValue(null) == variables.paramLabels[k]
            )
          message: "Cannot modify a Cluster API controlled label except to match the Cluster API mirrored machine. This is because status.authoritativeAPI is set to Cluster API."
        
        # Don't allow setting the 'machine-template-hash' label. It should only be set by the CAPI controllers.
        - expression: "variables.newLabels[?'machine-template-hash'].orValue(null) == variables.oldLabels[?'machine-template-hash'].orValue(null)"
          message: "Setting the 'machine-template-hash' label is forbidden.'"
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: cluster-api-machine-vap
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-cluster-api
      paramRef:
        namespace: openshift-machine-api
        # We 'Allow' here as we don't want to block CAPI Machine functionality
        # when no MAPI machine (param) exists. This might happen when a user
        # wants to not use MAPI, or is migrating.
        parameterNotFoundAction: Allow
        selector: {}
      policyName: cluster-api-machine-vap
      validationActions: [Deny]
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: cluster-api-machine-vap
    spec:
      failurePolicy: Fail
    
      paramKind:
        apiVersion: machine.openshift.io/v1beta1
        kind: Machine
    
      matchConstraints:
        resourceRules:
        - apiGroups:   ["cluster.x-k8s.io"]
          apiVersions: ["v1beta2"]
          operations:  ["UPDATE"]
          resources:   ["machines"]
    
      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-only-non-service-account-requests
          expression: >-
            !(request.userInfo.username in [
                "system:serviceaccount:openshift-machine-api:machine-api-controllers",
                "system:serviceaccount:openshift-cluster-api:cluster-capi-operator"
            ])
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'
        - name: check-authoritativeAPI-machineapi
          expression: "params.?status.?authoritativeAPI.orValue(\"\") == \"MachineAPI\""
      variables:
        # label maps
        - name: newLabels
          expression: "object.metadata.?labels.orValue({})"
        - name: oldLabels
          expression: "oldObject.metadata.?labels.orValue({})"
        - name: paramLabels
          expression: "params.metadata.?labels.orValue({})"
    
        # annotation maps
        - name: newAnn
          expression: "object.metadata.?annotations.orValue({})"
        - name: oldAnn
          expression: "oldObject.metadata.?annotations.orValue({})"
    
      # All validations must evaluate to TRUE
      validations:
        # Only spec.authoritativeAPI may change
        - expression: "object.spec == oldObject.spec"
          message:  "Changing .spec is not allowed. This is because status.authoritativeAPI is set to Machine API."
    
        # Guard machine.openshift.io/* and kubernetes.io/*  and cluster.x-k8s.io/* labels
        - expression: >
            !(
              variables.newLabels.exists(k,
                  (k.startsWith('machine.openshift.io') || k.startsWith('kubernetes.io') || k.contains('cluster.x-k8s.io/')) &&
                  (variables.oldLabels[?k].orValue(null) != variables.newLabels[k])
              ) ||
              variables.oldLabels.exists(k,
                  (k.startsWith('machine.openshift.io') || k.startsWith('kubernetes.io') || k.contains('cluster.x-k8s.io/')) &&
                  !(k in variables.newLabels)
              )
            )
          message: "Cannot add, modify or delete any machine.openshift.io/*, kubernetes.io/* or cluster.x-k8s.io/* label. This is because status.authoritativeAPI is set to Machine API."
    
        # Guard machine.openshift.io/* and cluster.x-k8s.io/* and clusters.x-k8s.io/* annotations
        - expression: >
            !(
              variables.newAnn.exists(k,
                  (k.startsWith('machine.openshift.io') || k.contains('cluster.x-k8s.io') || k.contains('clusters.x-k8s.io')) &&
                  (variables.oldAnn[?k].orValue(null) != variables.newAnn[k])
              ) ||
              variables.oldAnn.exists(k,
                  (k.startsWith('machine.openshift.io') || k.contains('cluster.x-k8s.io') || k.contains('clusters.x-k8s.io')) &&
                  !(k in variables.newAnn)
              )
            )
          message: "Cannot add, modify or delete any machine.openshift.io/* or cluster.x-k8s.io or clusters.x-k8s.io annotation. This is because status.authoritativeAPI is set to Machine API."
    
        # Param-controlled labels (labels on the MAPI machine) may change only to match the value on the MAPI Machine
        - expression: >
            variables.paramLabels.all(
              k,
              variables.newLabels[?k].orValue(null) == variables.oldLabels[?k].orValue(null) ||
              variables.newLabels[?k].orValue(null) == variables.paramLabels[k]
            )
          message: "Cannot modify a Machine API controlled label except to match the Machine API mirrored machine. This is because status.authoritativeAPI is set to Machine API."
        
        # Don't allow setting the 'machine-template-hash' label. It should only be set by the CAPI controllers.
        - expression: "variables.newLabels[?'machine-template-hash'].orValue(null) == variables.oldLabels[?'machine-template-hash'].orValue(null)"
          message: "Setting the 'machine-template-hash' label is forbidden.'"
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-cluster-api-prevent-setting-of-capi-fields-unsupported-by-mapi
    spec:
      failurePolicy: Fail
      matchConstraints:
        resourceRules:
          - apiGroups: ["cluster.x-k8s.io"]
            apiVersions: ["v1beta2"]
            operations: ["CREATE", "UPDATE"]
            resources: ["machines", "machinesets"]
      variables:
        - name: machineSpec
          expression: "object.kind == 'Machine' ? object.spec : object.spec.template.spec"
        - name: specPath
          expression: "object.kind == 'Machine' ? 'spec' : 'spec.template.spec'"
      validations:
        - expression: "!has(variables.machineSpec.version)"
          messageExpression: "variables.specPath + '.version is a forbidden field'"
        - expression: "!has(variables.machineSpec.readinessGates)"
          messageExpression: "variables.specPath + '.readinessGates is a forbidden field'"
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-cluster-api-prevent-setting-of-capi-fields-unsupported-by-mapi
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-cluster-api
      policyName: openshift-cluster-api-prevent-setting-of-capi-fields-unsupported-by-mapi
      validationActions:
          - Deny
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-only-create-mapi-machine-if-authoritative-api-capi
    spec:
      failurePolicy: Fail
      
      paramKind:
        apiVersion: cluster.x-k8s.io/v1beta2
        kind: Machine

      matchConstraints:
        resourceRules:
          - apiGroups: ["machine.openshift.io"]
            apiVersions: ["*"]
            operations: ["CREATE"]
            resources: ["machines"]
      
      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'

      # All validations must evaluate to true
      validations:
      - expression: 'object.spec.authoritativeAPI == "ClusterAPI"'
        messageExpression: "'Can\\'t create Machine API Machine ' + object.metadata.name + ' with authoritativeAPI=' + object.spec.?authoritativeAPI.orValue('<unset>') + ' because a Cluster API Machine with the same name already exists.'"
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-only-create-mapi-machine-if-authoritative-api-capi
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      paramRef:
        namespace: openshift-cluster-api
        # We 'Allow' here as we don't want to block MAPI Machine 
        # functionality when no CAPI machine (param) exists. 
        # This might happen when the synchronisation controller first
        # is installed or when an unmigrateable machine is encountered.
        parameterNotFoundAction: Allow
        selector: {}
      policyName: openshift-only-create-mapi-machine-if-authoritative-api-capi
      validationActions:
          - Deny
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-prevent-authoritative-mapi-machineset-create-when-capi-exists 
    spec:
      failurePolicy: Fail
      paramKind:
        apiVersion: cluster.x-k8s.io/v1beta2
        kind: MachineSet
      matchConstraints:
        resourceRules:
          - apiGroups: ["machine.openshift.io"]
            apiVersions: ["*"]
            operations: ["CREATE"]
            resources: ["machinesets"]
      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'
      # All validations must evaluate to true
      validations:
       # Only allow creation of a Machine API MachineSet with the same name as an
       # existing CAPI one if spec.authoritativeAPI == ClusterAPI
      - expression: 'object.spec.authoritativeAPI == "ClusterAPI"'
        messageExpression: "'Can\\'t create Machine API MachineSet ' + object.metadata.name + ' with spec.authoritativeAPI: ' + object.spec.?authoritativeAPI.orValue('<unset>') + ' because a Cluster API MachineSet with the same name already exists.'"
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-prevent-authoritative-mapi-machineset-create-when-capi-exists
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      paramRef:
        namespace: openshift-cluster-api
        # We 'Allow' here as we don't want to block MAPI MachineSet
        # functionality when no CAPI machineset (param) exists.
        # This might happen when the synchronisation controller first
        # is installed or when an unmigrateable machineset is encountered.
        parameterNotFoundAction: Allow
        selector: {}
      policyName: openshift-prevent-authoritative-mapi-machineset-create-when-capi-exists
      validationActions:
          - Deny
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-validate-capi-machine-creation
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-cluster-api
      paramRef:
        namespace: openshift-machine-api
        parameterNotFoundAction: Allow
        selector: {}
      policyName: openshift-validate-capi-machine-creation
      validationActions:
          - Deny
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-validate-capi-machine-creation 
    spec:
      failurePolicy: Fail
      paramKind:
        apiVersion: machine.openshift.io/v1beta1
        kind: Machine
      matchConstraints:
        resourceRules:
        - apiGroups:   ["cluster.x-k8s.io"]
          apiVersions: ["v1beta2"]
          operations:  ["CREATE"]
          resources:   ["machines"]
      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-only-non-service-account-requests
          expression: >-
            !(request.userInfo.username in [
                "system:serviceaccount:openshift-machine-api:machine-api-controllers",
                "system:serviceaccount:openshift-cluster-api:cluster-capi-operator"
            ])
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'
      variables:
        # Returns true if AuthoritativeAPI is MachineAPI
        - name: authoritativeAPIMAPI
          expression: "params.?status.?authoritativeAPI.orValue(\"\") == \"MachineAPI\""

        # Returns true if AuthoritativeAPI is ClusterAPI
        - name: authoritativeAPICAPI
          expression: "params.?status.?authoritativeAPI.orValue(\"\") == \"ClusterAPI\""

        # True when the **parameter Machine (MAPI)** is already paused
        - name: mapiPaused
          expression: >
            has(params.status.conditions) &&
            params.status.conditions.exists(c,
              c.type == 'Paused' && c.status == 'True')

        # True when the **CAPI Machine under admission** is paused
        - name: capiPaused
          expression: >
            (has(object.metadata.annotations) &&
            'cluster.x-k8s.io/paused' in object.metadata.annotations) ||
            (has(object.status) && has(object.status.conditions) &&
             object.status.conditions.exists(c,
               c.type == 'Paused' && c.status == 'True'))

      # All validations must evaluate to true
      validations:
      # If MachineAPI is authoritative, the new CAPI machine *must* be paused
      - expression: 'variables.authoritativeAPIMAPI ? variables.capiPaused : true'
        messageExpression: "'Can\\'t create Cluster API Machine ' + object.metadata.name + ' in an un-paused state. Either pause the machine, or change the authoritative API of the MAPI machine: ' + object.metadata.name +'.'"

      # If ClusterAPI is authoritative, deny unless the MAPI Machine is paused
      - expression: 'variables.authoritativeAPICAPI ? variables.mapiPaused : true'
        messageExpression: "'Can\\'t create Cluster API Machine ' + object.metadata.name + ' as a Machine API Machine with status.authoritativeAPI: ' + params.?status.?authoritativeAPI.orValue('<unset>') + ' already exists and is not paused. '"

    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-prevent-migration-when-machine-updating
    spec:
      failurePolicy: Fail
      matchConstraints:
        resourceRules:
          - apiGroups: ["machine.openshift.io"]
            apiVersions: ["*"]
            operations: ["UPDATE"]
            resources: ["machines"]

      # All validations must evaluate to true
      validations:
      - expression: '!(has(object.status) && has(object.status.phase) && object.status.phase == "Provisioning" && (oldObject.spec.authoritativeAPI != object.spec.authoritativeAPI))'
        message: 'Cannot update .spec.authoritativeAPI when machine is in Provisioning phase'
      - expression: '!(has(object.metadata.deletionTimestamp) && (oldObject.spec.authoritativeAPI != object.spec.authoritativeAPI))'
        message: 'Cannot update .spec.authoritativeAPI when machine has a non-zero deletion timestamp'
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-prevent-migration-when-machine-updating
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      policyName: openshift-prevent-migration-when-machine-updating
      validationActions:
          - Deny
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-provide-warning-when-not-synchronized
    spec:
      failurePolicy: Ignore

      matchConstraints:
        resourceRules:
          - apiGroups: ["machine.openshift.io"]
            apiVersions: ["*"]
            operations: ["UPDATE"]
            resources: ["machines"]
      variables:
        - name: syncCond
          expression: >
            has(object.status.conditions) ?
            object.status.conditions.exists(c, c.type == "Synchronized") :
            false
        - name: syncBad
          expression: >
              variables.syncCond &&
              object.status.conditions.exists(c,
                c.type == "Synchronized" &&
                (c.status == "False" || c.status == "Unknown")
              )
        - name: authAPIChanged
          expression: >
            oldObject.spec.authoritativeAPI != object.spec.authoritativeAPI

      # All validations must evaluate to true
      validations:
      - expression: '!variables.authAPIChanged || (variables.syncCond && !variables.syncBad)'
        message: 'Updating .spec.authoritativeAPI when the Synchronized condition is not true means changes may not take effect'
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-provide-warning-when-not-synchronized
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      policyName: openshift-provide-warning-when-not-synchronized
      validationActions:
          - Warn
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-mapi-authoritative-api-transition-requires-capi-infrastructure-ready-and-not-deleting
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      paramRef:
        namespace: openshift-cluster-api
        # We 'Allow' here as we don't want to block MAPI Machine
        # functionality when no CAPI machine (param) exists.
        # This might happen when the synchronisation controller first
        # is installed or when an unmigrateable machine is encountered.
        parameterNotFoundAction: Allow
        selector: {}
      policyName: openshift-mapi-authoritative-api-transition-requires-capi-infrastructure-ready-and-not-deleting
      validationActions: [Deny]
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-mapi-authoritative-api-transition-requires-capi-infrastructure-ready-and-not-deleting
    spec:
      failurePolicy: Fail

      paramKind:
        apiVersion: cluster.x-k8s.io/v1beta2
        kind: Machine

      matchConstraints:
        resourceRules:
        - apiGroups:   ["machine.openshift.io"]
          apiVersions: ["v1beta1"]
          operations:  ["UPDATE"]
          resources:   ["machines"]

      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-only-non-service-account-requests
          expression: >-
            !(request.userInfo.username in [
                "system:serviceaccount:openshift-machine-api:machine-api-controllers",
                "system:serviceaccount:openshift-cluster-api:cluster-capi-operator"
            ])
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'

      variables:
        - name: authAPIChanged
          expression: oldObject.spec.authoritativeAPI != object.spec.authoritativeAPI

        - name: capiInfraProvisioned
          expression: params.?status.?initialization.?infrastructureProvisioned.orValue(false)

        - name: capiDeleting
          expression: has(params.metadata.deletionTimestamp)

      # All validations must evaluate to TRUE
      validations:
        # Don't allow changing the AuthoritativeAPI if the CAPI Machine mirror infrastructureProvisioned is not true
        - name: block-when-not-infraProvisioned
          expression: >
            !(variables.authAPIChanged && !variables.capiInfraProvisioned)
          message: "spec.authoritativeAPI may only be updated when the Cluster API Machine's status.initialization.infrastructureProvisioned is true."

        # Don't allow changing the AuthoritativeAPI if the CAPI Machine mirror is deleting
        - name: block-when-capi-deleting
          expression: >
            !(variables.authAPIChanged && variables.capiDeleting)
          message: "spec.authoritativeAPI cannot be modified while the corresponding CAPI Machine is being deleted (metadata.deletionTimestamp is set)."
---
apiVersion: v1
kind: ConfigMap
metadata:
  annotations:
    exclude.release.openshift.io/internal-openshift-hosted: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/feature-set: CustomNoUpgrade,TechPreviewNoUpgrade
  name: cluster-api-aws-admission-policies
  namespace: openshift-cluster-api
  labels:
    provider.cluster.x-k8s.io/name: "openshift-cluster-api-aws"
    provider.cluster.x-k8s.io/type: "infrastructure"
    provider.cluster.x-k8s.io/version: "v0.0.0"
data:
  components: |-
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: "openshift-cluster-api-unsupported-aws-spec-fields"
    spec:
      policyName: "openshift-cluster-api-unsupported-aws-spec-fields"
      validationActions: [Deny]
      matchResources:
        namespaceSelector:
          matchExpressions:
          - key: kubernetes.io/metadata.name
            operator: In
            values:
            - openshift-cluster-api
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: "openshift-cluster-api-unsupported-aws-spec-fields"
    spec:
      failurePolicy: Fail
      matchConstraints:
        resourceRules:
        - apiGroups:   ["infrastructure.cluster.x-k8s.io"]
          apiVersions: ["v1beta2"]
          operations:  ["CREATE", "UPDATE"]
          resources:   ["awsmachines", "awsmachinetemplates"]
      variables:
        - name: machineSpec
          expression: "object.kind == 'AWSMachine' ? object.spec : object.spec.template.spec"
        - name: specPath
          expression: "object.kind == 'AWSMachine' ? 'spec' : 'spec.template.spec'"
      validations:
        - expression: "!has(variables.machineSpec.ami.eksLookupType)"
          messageExpression: "variables.specPath + '.ami.eksLookupType is a forbidden field'"
        - expression: "!has(variables.machineSpec.imageLookupFormat)"
          messageExpression: "variables.specPath + '.imageLookupFormat is a forbidden field'"
        - expression: "!has(variables.machineSpec.imageLookupOrg)"
          messageExpression: "variables.specPath + '.imageLookupOrg is a forbidden field'"
        - expression: "!has(variables.machineSpec.imageLookupBaseOS)"
          messageExpression: "variables.specPath + '.imageLookupBaseOS is a forbidden field'"
        - expression: "!has(variables.machineSpec.networkInterfaces)"
          messageExpression: "variables.specPath + '.networkInterfaces is a forbidden field'"
        - expression: "!has(variables.machineSpec.uncompressedUserData)"
          messageExpression: "variables.specPath + '.uncompressedUserData is a forbidden field'"
        - expression: "!has(variables.machineSpec.privateDnsName)"
          messageExpression: "variables.specPath + '.privateDnsName is a forbidden field'"
        - expression: "!has(variables.machineSpec.ignition) || !has(variables.machineSpec.ignition.proxy)"
          messageExpression: "variables.specPath + '.ignition.proxy is a forbidden field'"
        - expression: "!has(variables.machineSpec.ignition) || !has(variables.machineSpec.ignition.tls)"
          messageExpression: "variables.specPath + '.ignition.tls is a forbidden field'"
        - expression: "!has(variables.machineSpec.securityGroupOverrides)"
          messageExpression: "variables.specPath + '.securityGroupOverrides is a forbidden field'"
        - expression: >-
            !has(variables.machineSpec.cloudInit) || 
            (
             !has(variables.machineSpec.cloudInit.secretCount) &&
             !has(variables.machineSpec.cloudInit.secretPrefix) &&
             !has(variables.machineSpec.cloudInit.insecureSkipSecretsManager) &&
             !has(variables.machineSpec.cloudInit.secureSecretsBackend)
            )
          messageExpression: "variables.specPath + '.cloudInit is a forbidden field'"
