# apiVersion: v1
# kind: ConfigMap
# metadata:
#   annotations:
#     exclude.release.openshift.io/internal-openshift-hosted: "true"
#     include.release.openshift.io/self-managed-high-availability: "true"
#     include.release.openshift.io/single-node-developer: "true"
#     release.openshift.io/feature-set: CustomNoUpgrade,TechPreviewNoUpgrade
#   name: cluster-api-admission-policies
#   namespace: openshift-cluster-api
#   labels:
#     provider.cluster.x-k8s.io/name: "openshift-cluster-api"
#     provider.cluster.x-k8s.io/type: "core"
#     provider.cluster.x-k8s.io/version: "v0.0.0"
---
apiVersion: v1
kind: ConfigMap
metadata:
  annotations:
    exclude.release.openshift.io/internal-openshift-hosted: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/feature-set: CustomNoUpgrade,TechPreviewNoUpgrade
  name: cluster-api-custom-admission-policies
  namespace: openshift-cluster-api
  labels:
    provider.cluster.x-k8s.io/name: "openshift-cluster-api"
    provider.cluster.x-k8s.io/type: "core"
    provider.cluster.x-k8s.io/version: "v0.0.0"
data:
  components: |-
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: machine-api-machine-vap
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      paramRef:
        namespace: openshift-cluster-api
        # We 'Allow' here as we don't want to block MAPI Machine 
        # functionality when no CAPI machine (param) exists. 
        # This might happen when the synchronisation controller first
        # is installed or when an unmigrateable machine is encountered.
        parameterNotFoundAction: Allow
        selector: {}
      policyName: machine-api-machine-vap
      validationActions: [Deny]
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: machine-api-machine-vap
    spec:
      failurePolicy: Fail
    
      paramKind:
        apiVersion: cluster.x-k8s.io/v1beta1
        kind: Machine
    
      matchConstraints:
        resourceRules:
        - apiGroups:   ["machine.openshift.io"]
          apiVersions: ["v1beta1"]
          operations:  ["UPDATE"]
          resources:   ["machines"]
    
      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-only-non-service-account-requests
          expression: >-
            !(request.userInfo.username in [
                "system:serviceaccount:openshift-machine-api:machine-api-controllers",
                "system:serviceaccount:openshift-cluster-api:cluster-capi-operator"
            ])
        - name: check-authoritativeAPI-clusterapi
          expression: 'object.status.authoritativeAPI == "ClusterAPI"'
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'
    
      variables:
        # label maps
        - name: newLabels
          expression: "object.metadata.?labels.orValue({})"
        - name: oldLabels
          expression: "oldObject.metadata.?labels.orValue({})"
        - name: paramLabels
          expression: "params.metadata.?labels.orValue({})"
    
        # annotation maps
        - name: newAnn
          expression: "object.metadata.?annotations.orValue({})"
        - name: oldAnn
          expression: "oldObject.metadata.?annotations.orValue({})"
    
        - name: specLockedExceptAuthoritativeAPI
          expression: >
            [
              [object.spec.?lifecycleHooks,   oldObject.spec.?lifecycleHooks],
              [object.spec.?metadata,         oldObject.spec.?metadata],
              [object.spec.?providerID,       oldObject.spec.?providerID],
              [object.spec.?providerSpec,     oldObject.spec.?providerSpec],
              [object.spec.?taints,           oldObject.spec.?taints]
            ].all(p,
              p[0].hasValue()
                ? p[1].hasValue() && p[0].value() == p[1].value()
                : !p[1].hasValue()
            )
    
      # All validations must evaluate to TRUE
      validations:
        # Only spec.authoritativeAPI may change
        - expression: "variables.specLockedExceptAuthoritativeAPI"
          message:  "You may only modify spec.authoritativeAPI. Any other change inside .spec is not allowed. This is because status.authoritativeAPI is set to Cluster API."
    
        # Guard machine.openshift.io/* and kubernetes.io/* labels
        - expression: >
            !(
              variables.newLabels.exists(k,
                  (k.startsWith('machine.openshift.io') || k.startsWith('kubernetes.io')) &&
                  (variables.oldLabels[?k].orValue(null) != variables.newLabels[k])
              ) ||
              variables.oldLabels.exists(k,
                  (k.startsWith('machine.openshift.io') || k.startsWith('kubernetes.io')) &&
                  !(k in variables.newLabels)
              )
            )
          message: "Cannot add, modify or delete any machine.openshift.io/* or kubernetes.io/* label. This is because status.authoritativeAPI is set to Cluster API."
    
        # Guard machine.openshift.io/* annotations
        - expression: >
            !(
              variables.newAnn.exists(k,
                  k.startsWith('machine.openshift.io') &&
                  (variables.oldAnn[?k].orValue(null) != variables.newAnn[k])
              ) ||
              variables.oldAnn.exists(k,
                  k.startsWith('machine.openshift.io') &&
                  !(k in variables.newAnn)
              )
            )
          message: "Cannot add, modify or delete any machine.openshift.io/* annotation. This is because status.authoritativeAPI is set to Cluster API."
    
        # Param-controlled labels (labels on the CAPI machine) may change only to match the value on the CAPI Machine
        - expression: >
            variables.paramLabels.all(
              k,
              variables.newLabels[?k].orValue(null) == variables.oldLabels[?k].orValue(null) ||
              variables.newLabels[?k].orValue(null) == variables.paramLabels[k]
            )
          message: "Cannot modify a Cluster API controlled label except to match the Cluster API mirrored machine. This is because status.authoritativeAPI is set to Cluster API."
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-cluster-api-prevent-setting-of-capi-fields-unsupported-by-mapi
    spec:
      failurePolicy: Fail
      matchConstraints:
        resourceRules:
          - apiGroups: ["cluster.x-k8s.io"]
            apiVersions: ["*"]
            operations: ["CREATE", "UPDATE"]
            resources: ["machines", "machinesets"]
      variables:
      - name: machineSpec
        expression: "object.kind == 'Machine' ? object.spec : object.spec.template.spec"
      - name: specPath
        expression: "object.kind == 'Machine' ? 'spec' : 'spec.template.spec'"
      validations:
      - expression: "!has(variables.machineSpec.version)"
        messageExpression: "variables.specPath + '.version is a forbidden field'"
      - expression: "!has(variables.machineSpec.readinessGates)"
        messageExpression: "variables.specPath + '.readinessGates is a forbidden field'"
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-cluster-api-prevent-setting-of-capi-fields-unsupported-by-mapi
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-cluster-api
      policyName: openshift-cluster-api-prevent-setting-of-capi-fields-unsupported-by-mapi
      validationActions:
          - Deny
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: openshift-only-create-mapi-machine-if-authoritative-api-capi
    spec:
      failurePolicy: Fail
      
      paramKind:
        apiVersion: cluster.x-k8s.io/v1beta1
        kind: Machine

      matchConstraints:
        resourceRules:
          - apiGroups: ["machine.openshift.io"]
            apiVersions: ["*"]
            operations: ["CREATE"]
            resources: ["machines"]
      
      # Requests must satisfy every matchCondition to reach the validations
      matchConditions:
        - name: check-param-match
          expression: 'object.metadata.name == params.metadata.name'

      # All validations must evaluate to true
      validations:
      - expression: 'object.spec.authoritativeAPI == "ClusterAPI"'
        messageExpression: "'Can\\'t create Machine API Machine ' + object.metadata.name + ' with authoritativeAPI=' + object.spec.?authoritativeAPI.orValue('<unset>') + ' because a Cluster API Machine with the same name already exists.'"
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: openshift-only-create-mapi-machine-if-authoritative-api-capi
    spec:
      matchResources:
        namespaceSelector:
          matchLabels:
            kubernetes.io/metadata.name: openshift-machine-api
      paramRef:
        namespace: openshift-cluster-api
        # We 'Allow' here as we don't want to block MAPI Machine 
        # functionality when no CAPI machine (param) exists. 
        # This might happen when the synchronisation controller first
        # is installed or when an unmigrateable machine is encountered.
        parameterNotFoundAction: Allow
        selector: {}
      policyName: openshift-only-create-mapi-machine-if-authoritative-api-capi
      validationActions:
          - Deny
---
apiVersion: v1
kind: ConfigMap
metadata:
  annotations:
    exclude.release.openshift.io/internal-openshift-hosted: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/feature-set: CustomNoUpgrade,TechPreviewNoUpgrade
  name: cluster-api-aws-admission-policies
  namespace: openshift-cluster-api
  labels:
    provider.cluster.x-k8s.io/name: "openshift-cluster-api-aws"
    provider.cluster.x-k8s.io/type: "infrastructure"
    provider.cluster.x-k8s.io/version: "v0.0.0"
data:
  components: |-
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicyBinding
    metadata:
      name: "openshift-cluster-api-unsupported-aws-spec-fields"
    spec:
      policyName: "openshift-cluster-api-unsupported-aws-spec-fields"
      validationActions: [Deny]
      matchResources:
        namespaceSelector:
          matchExpressions:
          - key: kubernetes.io/metadata.name
            operator: In
            values:
            - openshift-cluster-api
    ---
    apiVersion: admissionregistration.k8s.io/v1
    kind: ValidatingAdmissionPolicy
    metadata:
      name: "openshift-cluster-api-unsupported-aws-spec-fields"
    spec:
      failurePolicy: Fail
      matchConstraints:
        resourceRules:
        - apiGroups:   ["infrastructure.cluster.x-k8s.io"]
          apiVersions: ["v1beta2"]
          operations:  ["CREATE", "UPDATE"]
          resources:   ["awsmachines", "awsmachinetemplates"]
      variables:
        - name: machineSpec
          expression: "object.kind == 'AWSMachine' ? object.spec : object.spec.template.spec"
        - name: specPath
          expression: "object.kind == 'AWSMachine' ? 'spec' : 'spec.template.spec'"
      validations:
        - expression: "!has(variables.machineSpec.ami.eksLookupType)"
          messageExpression: "variables.specPath + '.ami.eksLookupType is a forbidden field'"
        - expression: "!has(variables.machineSpec.imageLookupFormat)"
          messageExpression: "variables.specPath + '.imageLookupFormat is a forbidden field'"
        - expression: "!has(variables.machineSpec.imageLookupOrg)"
          messageExpression: "variables.specPath + '.imageLookupOrg is a forbidden field'"
        - expression: "!has(variables.machineSpec.imageLookupBaseOS)"
          messageExpression: "variables.specPath + '.imageLookupBaseOS is a forbidden field'"
        - expression: "!has(variables.machineSpec.networkInterfaces)"
          messageExpression: "variables.specPath + '.networkInterfaces is a forbidden field'"
        - expression: "!has(variables.machineSpec.uncompressedUserData)"
          messageExpression: "variables.specPath + '.uncompressedUserData is a forbidden field'"
        - expression: "!has(variables.machineSpec.privateDnsName)"
          messageExpression: "variables.specPath + '.privateDnsName is a forbidden field'"
        - expression: "!has(variables.machineSpec.ignition) || !has(variables.machineSpec.ignition.proxy)"
          messageExpression: "variables.specPath + '.ignition.proxy is a forbidden field'"
        - expression: "!has(variables.machineSpec.ignition) || !has(variables.machineSpec.ignition.tls)"
          messageExpression: "variables.specPath + '.ignition.tls is a forbidden field'"
        - expression: "!has(variables.machineSpec.securityGroupOverrides)"
          messageExpression: "variables.specPath + '.securityGroupOverrides is a forbidden field'"
        - expression: >-
            !has(variables.machineSpec.cloudInit) || 
            (
             !has(variables.machineSpec.cloudInit.secretCount) &&
             !has(variables.machineSpec.cloudInit.secretPrefix) &&
             !has(variables.machineSpec.cloudInit.insecureSkipSecretsManager) &&
             !has(variables.machineSpec.cloudInit.secureSecretsBackend)
            )
          messageExpression: "variables.specPath + '.cloudInit is a forbidden field'"
