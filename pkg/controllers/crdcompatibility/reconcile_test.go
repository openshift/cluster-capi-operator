/*
Copyright 2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package crdcompatibility

import (
	"context"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	operatorv1alpha1 "github.com/openshift/api/operator/v1alpha1"
	"github.com/openshift/cluster-capi-operator/pkg/controllers/crdcompatibility/crdvalidation"
	"github.com/openshift/cluster-capi-operator/pkg/test"
)

var _ = Describe("CRDCompatibilityRequirement", Ordered, ContinueOnFailure, func() {
	// Starting and stopping the manager is quite expensive, so we share one amongst all the tests.
	// Unfortunately ginkgo forces us to use Ordered when doing this.
	BeforeAll(func(ctx context.Context) {
		_, startManager := InitManager(ctx)

		startManager()
	})

	var (
		// testCRDClean is a CRD generated by generateTestCRD.
		// testCRDWorking is a copy of testCRDClean with runtime metadata.
		testCRDClean, testCRDWorking *apiextensionsv1.CustomResourceDefinition
	)

	BeforeEach(func(ctx context.Context) {
		testCRDClean = test.GenerateTestCRD()
		testCRDWorking = testCRDClean.DeepCopy()
	})

	Context("When creating a CRDCompatibilityRequirement", func() {
		BeforeEach(func(ctx context.Context) {
			createTestObject(ctx, testCRDWorking, "CRD")
		})

		It("Should set all conditions and observed CRD", func(ctx context.Context) {
			requirement := generateTestRequirement(testCRDClean)
			createTestObject(ctx, requirement, "CRDCompatibilityRequirement")

			By("Waiting for the CRDCompatibilityRequirement to have the expected status")
			Eventually(kWithCtx(ctx).Object(requirement)).Should(SatisfyAll(
				test.HaveCondition("Progressing", metav1.ConditionFalse,
					test.WithConditionReason(operatorv1alpha1.CRDCompatibilityProgressingReasonUpToDate),
					test.WithConditionMessage("The CRDCompatibilityRequirement is up to date")),
				test.HaveCondition("Admitted", metav1.ConditionTrue,
					test.WithConditionReason(operatorv1alpha1.CRDCompatibilityAdmittedReasonAdmitted),
					test.WithConditionMessage("The CRDCompatibilityRequirement has been admitted")),
				test.HaveCondition("Compatible", metav1.ConditionTrue,
					test.WithConditionReason(operatorv1alpha1.CRDCompatibilityCompatibleReasonCompatible),
					test.WithConditionMessage("The CRD is compatible with this requirement")),
				HaveField("Status.ObservedCRD.UID", BeEquivalentTo(testCRDWorking.UID)),
				HaveField("Status.ObservedCRD.Generation", BeEquivalentTo(testCRDWorking.Generation)),
			))
		})

		It("Should correctly update observed generation on conditions", func(ctx context.Context) {
			requirement := generateTestRequirement(testCRDClean)
			createTestObject(ctx, requirement, "CRDCompatibilityRequirement")

			generation := requirement.GetGeneration()
			checkForStatusWithGeneration := func(generation int64) {
				Eventually(kWithCtx(ctx).Object(requirement)).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse,
						test.WithConditionReason(operatorv1alpha1.CRDCompatibilityProgressingReasonUpToDate),
						test.WithConditionMessage("The CRDCompatibilityRequirement is up to date"),
						test.WithConditionObservedGeneration(generation),
					),
					test.HaveCondition("Admitted", metav1.ConditionTrue,
						test.WithConditionReason(operatorv1alpha1.CRDCompatibilityAdmittedReasonAdmitted),
						test.WithConditionMessage("The CRDCompatibilityRequirement has been admitted"),
						test.WithConditionObservedGeneration(generation),
					),
					test.HaveCondition("Compatible", metav1.ConditionTrue,
						test.WithConditionReason(operatorv1alpha1.CRDCompatibilityCompatibleReasonCompatible),
						test.WithConditionMessage("The CRD is compatible with this requirement"),
						test.WithConditionObservedGeneration(generation),
					),
				))
			}

			By("Waiting for the CRDCompatibilityRequirement to have the expected status with observed generation 1")
			checkForStatusWithGeneration(generation)

			// Update the requirement to bump the generation
			Eventually(kWithCtx(ctx).Update(requirement, func() {
				requirement.Spec.CRDAdmitAction = operatorv1alpha1.CRDAdmitActionWarn
			})).Should(Succeed())

			// Sanity check that the generation has been bumped
			Expect(requirement).To(HaveField("ObjectMeta.Generation", BeNumerically(">", generation)))
			generation = requirement.GetGeneration()

			By("Waiting for the CRDCompatibilityRequirement to have the expected status with observed generation 2")
			checkForStatusWithGeneration(generation)
		})

		It("Should not admit a CRDCompatibilityRequirement if the CompatibilityCRD does not parse", func(ctx context.Context) {
			requirement := generateTestRequirement(testCRDClean)
			requirement.Spec.CompatibilityCRD = "not YAML"

			By("Attempting to create invalid CRDCompatibilityRequirement " + requirement.Name)
			expectedError := "admission webhook \"crdcompatibility.operator.openshift.io\" denied the request: expected a valid CustomResourceDefinition in YAML format: error unmarshaling JSON: while decoding JSON: json: cannot unmarshal string into Go value of type v1.CustomResourceDefinition"
			Eventually(tryCreate(ctx, requirement)).Should(MatchError(expectedError))
		})

		It("Should not admit a CRDCompatibilityRequirement if the CompatibilityCRD parses but is not a CRD", func(ctx context.Context) {
			requirement := generateTestRequirement(testCRDClean)
			requirement.Spec.CompatibilityCRD = "{}"

			By("Attempting to create invalid CRDCompatibilityRequirement " + requirement.Name)
			expectedError := "admission webhook \"crdcompatibility.operator.openshift.io\" denied the request: expected a valid CustomResourceDefinition in YAML format: expected APIVersion to be apiextensions.k8s.io/v1 and Kind to be CustomResourceDefinition, got /"
			Eventually(tryCreate(ctx, requirement)).Should(MatchError(expectedError))
		})

		It("Should not set an error when the CRD is not found", func(ctx context.Context) {
			requirement := generateTestRequirement(testCRDClean)
			// requirement.Spec.CRDRef = "tests.example.com"

			createTestObject(ctx, requirement, "CRDCompatibilityRequirement")

			By("Waiting for the CRDCompatibilityRequirement to have the expected status")
			Eventually(kWithCtx(ctx).Object(requirement)).Should(SatisfyAll(
				test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityProgressingReasonUpToDate), test.WithConditionMessage("The CRDCompatibilityRequirement is up to date")),

				// observed CRD should be empty
				HaveField("Status.ObservedCRD", BeZero()),
			))
		})

		Context("When creating a CRDCompatibilityRequirement which is not compatible with the current CRD", func() {
			addProperty := func(crd *apiextensionsv1.CustomResourceDefinition, prop string) func() {
				return func() {
					crd.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties[prop] = apiextensionsv1.JSONSchemaProps{
						Type: "string",
					}
				}
			}

			var (
				incompatibleCRD *apiextensionsv1.CustomResourceDefinition
				requirement     *operatorv1alpha1.CRDCompatibilityRequirement
			)

			BeforeEach(func(ctx context.Context) {
				// Create a compatibility CRD which requires an extra field
				incompatibleCRD = testCRDClean.DeepCopy()
				addProperty(incompatibleCRD, "extra")()

				By("Creating a new CRDCompatibilityRequirement with a compatibility CRD which requires an extra field")
				requirement = generateTestRequirement(incompatibleCRD)
				createTestObject(ctx, requirement, "CRDCompatibilityRequirement")
			})

			It("Should set not Compatible", func(ctx context.Context) {
				By("Checking that the CRDCompatibilityRequirement is admitted but not compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityProgressingReasonUpToDate)),
					test.HaveCondition("Admitted", metav1.ConditionTrue, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityAdmittedReasonAdmitted)),
					test.HaveCondition("Compatible", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityCompatibleReasonRequirementsNotMet)),
				))
			})

			It("Should permit the CRD to be updated to be compatible", func(ctx context.Context) {
				By("Checking that the CRDCompatibilityRequirement is not compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityProgressingReasonUpToDate)),
					test.HaveCondition("Compatible", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityCompatibleReasonRequirementsNotMet)),
				))

				By("Updating the CRD to add the extra field")
				Eventually(kWithCtx(ctx).Update(testCRDWorking, addProperty(testCRDWorking, "extra"))).Should(Succeed())

				By("Checking that the CRDCompatibilityRequirement becomes compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityProgressingReasonUpToDate)),
					test.HaveCondition("Compatible", metav1.ConditionTrue, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityCompatibleReasonCompatible)),
				))
			})

			It("Should not permit the CRD to be updated if it would remain incompatible", func(ctx context.Context) {
				By("Checking that the CRDCompatibilityRequirement is not compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityProgressingReasonUpToDate)),
					test.HaveCondition("Compatible", metav1.ConditionFalse, test.WithConditionReason(operatorv1alpha1.CRDCompatibilityCompatibleReasonRequirementsNotMet)),
				))

				By("Attempt to update the CRD to add a different extra field")
				expectedError := "admission webhook \"crdcompatibility.operator.openshift.io\" denied the request: CRD is not compatible with CRDCompatibilityRequirements: This requirement was added by Test Creator: requirement " + requirement.Name + ": removed field : v1.^.extra"
				Eventually(kWithCtx(ctx).Update(testCRDWorking, addProperty(testCRDWorking, "extra2"))).Should(MatchError(expectedError))
			})
		})

	})

	Context("When creating or modifying a CRD", func() {
		testIncompatibleCRD := func(ctx context.Context, testCRD *apiextensionsv1.CustomResourceDefinition, requirement *operatorv1alpha1.CRDCompatibilityRequirement, createOrUpdateCRD func(context.Context, client.Object, func()) func() error) {
			// Create a working copy of the CRD so we maintain a clean version
			// without runtime metadata
			testCRDWorking := testCRD.DeepCopy()

			By("Attempting to make an invalid modification by removing a field")
			expectedError := "admission webhook \"crdcompatibility.operator.openshift.io\" denied the request: CRD is not compatible with CRDCompatibilityRequirements: This requirement was added by Test Creator: requirement " + requirement.Name + ": removed field : v1.^.status"
			updateCRD := createOrUpdateCRD(ctx, testCRDWorking, func() {
				delete(testCRDWorking.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties, "status")
			})
			Eventually(updateCRD).Should(MatchError(expectedError))
		}

		testCompatibleCRD := func(ctx context.Context, testCRD *apiextensionsv1.CustomResourceDefinition, createOrUpdateCRD func(context.Context, client.Object, func()) func() error) {
			// Create a working copy of the CRD so we maintain a clean version
			// without runtime metadata
			testCRDWorking := testCRD.DeepCopy()

			By("Attempting to make a valid modification by adding a field")
			updateCRD := createOrUpdateCRD(ctx, testCRDWorking, func() {
				testCRDWorking.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties["foo"] = apiextensionsv1.JSONSchemaProps{
					Type: "string",
				}
			})
			Eventually(updateCRD).Should(Succeed(), "The test CRD should be modified")
		}

		Context("When modifying a CRD with a requirement", func() {
			var (
				requirement *operatorv1alpha1.CRDCompatibilityRequirement
			)

			BeforeEach(func(ctx context.Context) {
				createTestObject(ctx, testCRDWorking, "CRD")

				requirement = generateTestRequirement(testCRDClean)
				createTestObject(ctx, requirement, "CRDCompatibilityRequirement")
				waitForAdmitted(ctx, requirement)
			})

			It("Should not permit a CRD with requirements to be deleted", func(ctx context.Context) {
				By("Attempting to delete CRD " + testCRDClean.Name)
				Eventually(tryDelete(ctx, testCRDClean)).Should(MatchError(ContainSubstring(crdvalidation.ErrCRDHasRequirements.Error())), "The test CRD should not be deleted")
			})

			updateCRD := func(ctx context.Context, obj client.Object, updateFn func()) func() error {
				return kWithCtx(ctx).Update(obj, updateFn)
			}

			It("Should not permit an incompatible CRD modification", func(ctx context.Context) {
				testIncompatibleCRD(ctx, testCRDClean, requirement, updateCRD)
			})

			It("Should permit a compatible CRD modification", func(ctx context.Context) {
				testCompatibleCRD(ctx, testCRDClean, updateCRD)
			})
		})

		Context("When creating a CRD with a requirement", func() {
			var (
				requirement *operatorv1alpha1.CRDCompatibilityRequirement
			)

			BeforeEach(func(ctx context.Context) {
				testCRDWorking = test.GenerateTestCRD()

				// We need to register this before the requirement is created so
				// it will be deleted after the requirement is deleted
				deferCleanupTestObject(testCRDWorking, "CRD")

				requirement = generateTestRequirement(testCRDWorking)
				createTestObject(ctx, requirement, "CRDCompatibilityRequirement")
				waitForAdmitted(ctx, requirement)
			})

			createCRD := func(ctx context.Context, obj client.Object, updateFn func()) func() error {
				return func() error {
					By("Creating test CRD " + obj.GetName())

					updateFn()

					return cl.Create(ctx, obj)
				}
			}

			It("Should not permit an incompatible CRD to be created", func(ctx context.Context) {
				testIncompatibleCRD(ctx, testCRDWorking, requirement, createCRD)
			})

			It("Should permit a compatible CRD to be created", func(ctx context.Context) {
				testCompatibleCRD(ctx, testCRDWorking, createCRD)
			})
		})
	})
})
