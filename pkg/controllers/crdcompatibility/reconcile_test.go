/*
Copyright 2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package crdcompatibility

import (
	"context"
	"fmt"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"

	apiextensionsv1alpha1 "github.com/openshift/api/apiextensions/v1alpha1"
	"github.com/openshift/cluster-capi-operator/pkg/controllers/crdcompatibility/crdvalidation"
	"github.com/openshift/cluster-capi-operator/pkg/controllers/crdcompatibility/objectvalidation"
	"github.com/openshift/cluster-capi-operator/pkg/test"
)

var _ = Describe("CompatibilityRequirement", Ordered, ContinueOnFailure, func() {
	// Starting and stopping the manager is quite expensive, so we share one amongst all the tests.
	// Unfortunately ginkgo forces us to use Ordered when doing this.
	BeforeAll(func(ctx context.Context) {
		_, startManager := InitManager(ctx)

		startManager()
	})

	var (
		// testCRDClean is a CRD generated by generateTestCRD.
		// testCRDWorking is a copy of testCRDClean with runtime metadata.
		testCRDClean, testCRDWorking *apiextensionsv1.CustomResourceDefinition
	)

	BeforeEach(func(ctx context.Context) {
		testCRDClean = test.GenerateTestCRD()
		testCRDWorking = testCRDClean.DeepCopy()
	})

	Context("When creating a CompatibilityRequirement", func() {
		BeforeEach(func(ctx context.Context) {
			createTestObject(ctx, testCRDWorking, "CRD")
		})

		It("Should set all conditions and observed CRD", func(ctx context.Context) {
			requirement := test.GenerateTestCompatibilityRequirement(testCRDClean)
			createTestObject(ctx, requirement, "CompatibilityRequirement")

			By("Waiting for the CompatibilityRequirement to have the expected status")
			Eventually(kWithCtx(ctx).Object(requirement)).WithContext(ctx).Should(SatisfyAll(
				test.HaveCondition("Progressing", metav1.ConditionFalse,
					test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementUpToDateReason),
					test.WithConditionMessage("The CompatibilityRequirement is up to date")),
				test.HaveCondition("Admitted", metav1.ConditionTrue,
					test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementAdmittedReason),
					test.WithConditionMessage("The CompatibilityRequirement has been admitted")),
				test.HaveCondition("Compatible", metav1.ConditionTrue,
					test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementCompatibleReason),
					test.WithConditionMessage("The CRD is compatible with this requirement")),
				HaveField("Status.ObservedCRD.UID", BeEquivalentTo(testCRDWorking.UID)),
				HaveField("Status.ObservedCRD.Generation", BeEquivalentTo(testCRDWorking.Generation)),
			))
		})

		It("Should correctly update observed generation on conditions", func(ctx context.Context) {
			requirement := test.GenerateTestCompatibilityRequirement(testCRDClean)
			createTestObject(ctx, requirement, "CompatibilityRequirement")

			generation := requirement.GetGeneration()
			checkForStatusWithGeneration := func(generation int64) {
				Eventually(kWithCtx(ctx).Object(requirement)).WithContext(ctx).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse,
						test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementUpToDateReason),
						test.WithConditionMessage("The CompatibilityRequirement is up to date"),
						test.WithConditionObservedGeneration(generation),
					),
					test.HaveCondition("Admitted", metav1.ConditionTrue,
						test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementAdmittedReason),
						test.WithConditionMessage("The CompatibilityRequirement has been admitted"),
						test.WithConditionObservedGeneration(generation),
					),
					test.HaveCondition("Compatible", metav1.ConditionTrue,
						test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementCompatibleReason),
						test.WithConditionMessage("The CRD is compatible with this requirement"),
						test.WithConditionObservedGeneration(generation),
					),
				))
			}

			By("Waiting for the CompatibilityRequirement to have the expected status with observed generation 1")
			checkForStatusWithGeneration(generation)

			// Update the requirement to bump the generation
			Eventually(kWithCtx(ctx).Update(requirement, func() {
				requirement.Spec.CustomResourceDefinitionSchemaValidation.Action = apiextensionsv1alpha1.CRDAdmitActionWarn
			})).WithContext(ctx).Should(Succeed())

			// Sanity check that the generation has been bumped
			Expect(requirement).To(HaveField("ObjectMeta.Generation", BeNumerically(">", generation)))
			generation = requirement.GetGeneration()

			By("Waiting for the CompatibilityRequirement to have the expected status with observed generation 2")
			checkForStatusWithGeneration(generation)
		})

		It("Should not admit a CompatibilityRequirement if the CompatibilitySchema.CRDYAML does not parse", func(ctx context.Context) {
			requirement := test.GenerateTestCompatibilityRequirement(testCRDClean)
			requirement.Spec.CompatibilitySchema.CustomResourceDefinition.Data = "not YAML"

			By("Attempting to create invalid CompatibilityRequirement " + requirement.Name)
			expectedError := "admission webhook \"compatibilityrequirement.operator.openshift.io\" denied the request: expected a valid CustomResourceDefinition in YAML format: error unmarshaling JSON: while decoding JSON: json: cannot unmarshal string into Go value of type v1.CustomResourceDefinition"
			Eventually(tryCreate(ctx, requirement)).WithContext(ctx).Should(MatchError(expectedError))
		})

		It("Should not admit a CompatibilityRequirement if the CompatibilitySchema.CRDYAML parses but is not a CRD", func(ctx context.Context) {
			requirement := test.GenerateTestCompatibilityRequirement(testCRDClean)
			requirement.Spec.CompatibilitySchema.CustomResourceDefinition.Data = "{}"

			By("Attempting to create invalid CompatibilityRequirement " + requirement.Name)
			expectedError := "admission webhook \"compatibilityrequirement.operator.openshift.io\" denied the request: expected a valid CustomResourceDefinition in YAML format: expected APIVersion to be apiextensions.k8s.io/v1 and Kind to be CustomResourceDefinition, got /"
			Eventually(tryCreate(ctx, requirement)).WithContext(ctx).Should(MatchError(expectedError))
		})

		It("Should not set an error when the CRD is not found", func(ctx context.Context) {
			differentCRD := test.GenerateTestCRD()
			requirement := test.GenerateTestCompatibilityRequirement(differentCRD)

			createTestObject(ctx, requirement, "CompatibilityRequirement")

			By("Waiting for the CompatibilityRequirement to have the expected status")
			Eventually(kWithCtx(ctx).Object(requirement)).WithContext(ctx).Should(SatisfyAll(
				test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementUpToDateReason), test.WithConditionMessage("The CompatibilityRequirement is up to date")),

				// observed CRD should be empty
				HaveField("Status.ObservedCRD.UID", BeZero()),
				HaveField("Status.ObservedCRD.Generation", BeZero()),
			))
		})

		Context("When creating a CompatibilityRequirement which is not compatible with the current CRD", func() {
			addProperty := func(crd *apiextensionsv1.CustomResourceDefinition, prop string) func() {
				return func() {
					crd.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties[prop] = apiextensionsv1.JSONSchemaProps{
						Type: "string",
					}
				}
			}

			var (
				incompatibleCRD *apiextensionsv1.CustomResourceDefinition
				requirement     *apiextensionsv1alpha1.CompatibilityRequirement
			)

			BeforeEach(func(ctx context.Context) {
				// Create a compatibility CRD which requires an extra field
				incompatibleCRD = testCRDClean.DeepCopy()
				addProperty(incompatibleCRD, "extra")()

				By("Creating a new CompatibilityRequirement with a compatibility CRD which requires an extra field")
				requirement = test.GenerateTestCompatibilityRequirement(incompatibleCRD)
				createTestObject(ctx, requirement, "CompatibilityRequirement")
			})

			It("Should set not Compatible", func(ctx context.Context) {
				By("Checking that the CompatibilityRequirement is admitted but not compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).WithContext(ctx).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementUpToDateReason)),
					test.HaveCondition("Admitted", metav1.ConditionTrue, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementAdmittedReason)),
					test.HaveCondition("Compatible", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementRequirementsNotMetReason)),
				))
			})

			It("Should permit the CRD to be updated to be compatible", func(ctx context.Context) {
				By("Checking that the CompatibilityRequirement is not compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).WithContext(ctx).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementUpToDateReason)),
					test.HaveCondition("Compatible", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementRequirementsNotMetReason)),
				))

				By("Updating the CRD to add the extra field")
				Eventually(kWithCtx(ctx).Update(testCRDWorking, addProperty(testCRDWorking, "extra"))).WithContext(ctx).Should(Succeed())

				By("Checking that the CompatibilityRequirement becomes compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).WithContext(ctx).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementUpToDateReason)),
					test.HaveCondition("Compatible", metav1.ConditionTrue, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementCompatibleReason)),
				))
			})

			It("Should not permit the CRD to be updated if it would remain incompatible", func(ctx context.Context) {
				By("Checking that the CompatibilityRequirement is not compatible")
				Eventually(kWithCtx(ctx).Object(requirement)).WithContext(ctx).Should(SatisfyAll(
					test.HaveCondition("Progressing", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementUpToDateReason)),
					test.HaveCondition("Compatible", metav1.ConditionFalse, test.WithConditionReason(apiextensionsv1alpha1.CompatibilityRequirementRequirementsNotMetReason)),
				))

				By("Attempt to update the CRD to add a different extra field")
				expectedError := "admission webhook \"compatibilityrequirement.operator.openshift.io\" denied the request: CRD is not compatible with CompatibilityRequirements: This requirement was added by CompatibilityRequirement " + requirement.Name + ": removed field : v1.^.extra"
				Eventually(kWithCtx(ctx).Update(testCRDWorking, addProperty(testCRDWorking, "extra2"))).WithContext(ctx).Should(MatchError(expectedError))
			})
		})

	})

	Context("When creating a CompatibilityRequirement with configured object schema validation", Ordered, func() {
		var webhookConfig *admissionregistrationv1.ValidatingWebhookConfiguration
		var requirement *apiextensionsv1alpha1.CompatibilityRequirement

		BeforeAll(func(ctx context.Context) {
			requirement = test.GenerateTestCompatibilityRequirement(testCRDClean)
			requirement.Spec.ObjectSchemaValidation = apiextensionsv1alpha1.ObjectSchemaValidation{
				Action: apiextensionsv1alpha1.CRDAdmitActionDeny,
				NamespaceSelector: metav1.LabelSelector{
					MatchLabels: map[string]string{
						"test": "test",
					},
				},
				ObjectSelector: metav1.LabelSelector{
					MatchLabels: map[string]string{
						"test": "test",
					},
				},
				MatchConditions: []admissionregistrationv1.MatchCondition{
					{
						Name:       "test",
						Expression: "true",
					},
				},
			}

			createTestObject(ctx, requirement, "CompatibilityRequirement")

			webhookConfig = &admissionregistrationv1.ValidatingWebhookConfiguration{
				ObjectMeta: metav1.ObjectMeta{
					Name: requirement.Name,
				},
			}
		})

		It("Should create a validating webhook configuration to implement the compatiblity requirement", func(ctx context.Context) {
			Eventually(kWithCtx(ctx).Object(webhookConfig)).Should(SatisfyAll(
				HaveField("ObjectMeta.Name", BeEquivalentTo(requirement.Name)),
				HaveField("ObjectMeta.Annotations", HaveKey("service.beta.openshift.io/inject-cabundle")),
				HaveField("Webhooks", ConsistOf(SatisfyAll(
					HaveField("Name", BeEquivalentTo("compatibilityrequirement.operator.openshift.io")),
					HaveField("ClientConfig.Service.Name", BeEquivalentTo("compatibility-requirements-controllers-validation-webhook-service")),
					HaveField("ClientConfig.Service.Namespace", BeEquivalentTo("openshift-compatibility-requirements-operator")),
					HaveField("ClientConfig.Service.Path", HaveValue(BeEquivalentTo(fmt.Sprintf("%s%s", objectvalidation.WebhookPrefix, requirement.Name)))),
					HaveField("SideEffects", HaveValue(BeEquivalentTo(admissionregistrationv1.SideEffectClassNone))),
					HaveField("FailurePolicy", HaveValue(BeEquivalentTo(admissionregistrationv1.Fail))),
					HaveField("MatchPolicy", HaveValue(BeEquivalentTo(admissionregistrationv1.Exact))),
					HaveField("Rules", ConsistOf(SatisfyAll(
						HaveField("APIGroups", BeEquivalentTo([]string{testCRDClean.Spec.Group})),
						HaveField("APIVersions", BeEquivalentTo([]string{testCRDClean.Spec.Versions[0].Name})),
						HaveField("Resources", BeEquivalentTo([]string{testCRDClean.Spec.Names.Plural, testCRDClean.Spec.Names.Plural + "/status"})),
						HaveField("Scope", HaveValue(BeEquivalentTo(admissionregistrationv1.ScopeType(testCRDClean.Spec.Scope)))),
						HaveField("Operations", ConsistOf(
							BeEquivalentTo("CREATE"),
							BeEquivalentTo("UPDATE"),
						)),
					))),
				))),
			))
		})

		It("Should delete the validating webhook configuration when the CompatibilityRequirement is deleted", func(ctx context.Context) {
			Expect(cl.Delete(ctx, requirement)).To(Succeed())
			Eventually(kWithCtx(ctx).Get(webhookConfig)).Should(test.BeK8SNotFound())
		})
	})

	Context("When creating or modifying a CRD", func() {
		testIncompatibleCRD := func(ctx context.Context, testCRD *apiextensionsv1.CustomResourceDefinition, requirement *apiextensionsv1alpha1.CompatibilityRequirement, createOrUpdateCRD func(context.Context, client.Object, func()) func() error) {
			// Create a working copy of the CRD so we maintain a clean version
			// without runtime metadata
			testCRDWorking := testCRD.DeepCopy()

			By("Attempting to make an invalid modification by removing a field")
			expectedError := "admission webhook \"compatibilityrequirement.operator.openshift.io\" denied the request: CRD is not compatible with CompatibilityRequirements: This requirement was added by CompatibilityRequirement " + requirement.Name + ": removed field : v1.^.status"
			updateCRD := createOrUpdateCRD(ctx, testCRDWorking, func() {
				delete(testCRDWorking.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties, "status")
			})
			Eventually(updateCRD).WithContext(ctx).Should(MatchError(expectedError))
		}

		testCompatibleCRD := func(ctx context.Context, testCRD *apiextensionsv1.CustomResourceDefinition, createOrUpdateCRD func(context.Context, client.Object, func()) func() error) {
			// Create a working copy of the CRD so we maintain a clean version
			// without runtime metadata
			testCRDWorking := testCRD.DeepCopy()

			By("Attempting to make a valid modification by adding a field")
			updateCRD := createOrUpdateCRD(ctx, testCRDWorking, func() {
				testCRDWorking.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties["foo"] = apiextensionsv1.JSONSchemaProps{
					Type: "string",
				}
			})
			Eventually(updateCRD).WithContext(ctx).Should(Succeed(), "The test CRD should be modified")
		}

		Context("When modifying a CRD with a requirement", func() {
			var (
				requirement *apiextensionsv1alpha1.CompatibilityRequirement
			)

			BeforeEach(func(ctx context.Context) {
				createTestObject(ctx, testCRDWorking, "CRD")

				requirement = test.GenerateTestCompatibilityRequirement(testCRDClean)
				createTestObject(ctx, requirement, "CompatibilityRequirement")
				waitForAdmitted(ctx, requirement)
			})

			It("Should not permit a CRD with requirements to be deleted", func(ctx context.Context) {
				By("Attempting to delete CRD " + testCRDClean.Name)
				Eventually(tryDelete(ctx, testCRDClean)).WithContext(ctx).Should(MatchError(ContainSubstring(crdvalidation.ErrCRDHasRequirements.Error())), "The test CRD should not be deleted")
			})

			updateCRD := func(ctx context.Context, obj client.Object, updateFn func()) func() error {
				return kWithCtx(ctx).Update(obj, updateFn)
			}

			It("Should not permit an incompatible CRD modification", func(ctx context.Context) {
				testIncompatibleCRD(ctx, testCRDClean, requirement, updateCRD)
			})

			It("Should permit a compatible CRD modification", func(ctx context.Context) {
				testCompatibleCRD(ctx, testCRDClean, updateCRD)
			})
		})

		Context("When creating a CRD with a requirement", func() {
			var (
				requirement *apiextensionsv1alpha1.CompatibilityRequirement
			)

			BeforeEach(func(ctx context.Context) {
				testCRDWorking = test.GenerateTestCRD()

				// We need to register this before the requirement is created so
				// it will be deleted after the requirement is deleted
				deferCleanupTestObject(testCRDWorking, "CRD")

				requirement = test.GenerateTestCompatibilityRequirement(testCRDWorking)
				createTestObject(ctx, requirement, "CompatibilityRequirement")
				waitForAdmitted(ctx, requirement)
			})

			createCRD := func(ctx context.Context, obj client.Object, updateFn func()) func() error {
				return func() error {
					By("Creating test CRD " + obj.GetName())

					updateFn()

					return cl.Create(ctx, obj)
				}
			}

			It("Should not permit an incompatible CRD to be created", func(ctx context.Context) {
				testIncompatibleCRD(ctx, testCRDWorking, requirement, createCRD)
			})

			It("Should permit a compatible CRD to be created", func(ctx context.Context) {
				testCompatibleCRD(ctx, testCRDWorking, createCRD)
			})
		})

		Context("When creating a CRD with a requirement which has no CustomResourceDefinitionSchemaValidation", func() {
			var (
				requirement *apiextensionsv1alpha1.CompatibilityRequirement
			)

			BeforeEach(func(ctx context.Context) {
				testCRDWorking = test.GenerateTestCRD()
				deferCleanupTestObject(testCRDWorking, "CRD")

				requirement = test.GenerateTestCompatibilityRequirement(testCRDWorking)
				requirement.Spec.CustomResourceDefinitionSchemaValidation = (apiextensionsv1alpha1.CustomResourceDefinitionSchemaValidation{})

				createTestObject(ctx, requirement, "CompatibilityRequirement")
				waitForAdmitted(ctx, requirement)
			})

			createCRD := func(ctx context.Context, obj client.Object, updateFn func()) func() error {
				return func() error {
					By("Creating test CRD " + obj.GetName())

					updateFn()

					return cl.Create(ctx, obj)
				}
			}

			It("Should permit a compatible CRD to be created", func(ctx context.Context) {
				testCompatibleCRD(ctx, testCRDWorking, createCRD)
			})

			It("Should permit an incompatible CRD to be created", func(ctx context.Context) {
				updateCRD := createCRD(ctx, testCRDWorking, func() {
					delete(testCRDWorking.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties, "status")
				})
				Eventually(updateCRD).WithContext(ctx).Should(Succeed(), "The test CRD should be modified")
			})
		})
	})
})
